＃ブロックバインディング

伝統的に、変数の宣言の動作方法は、JavaScriptのプログラミングの難題の1つです。 ほとんどのC言語では、宣言が発生する場所に変数(または* bindings *)が生成されます。 しかし、JavaScriptでは、そうではありません。 変数が実際に生成される場所は、宣言方法によって異なります。また、ECMAScript6では、制御範囲を簡単にするオプションも用意されています。 この章では、古典的な`var`宣言が紛らわしいことを示し、ECMAScript6でブロックレベルのバインディングを導入し、それらを使用するためのベストプラクティスを提供します。

## Var宣言とホイスト

`var`を使った変数宣言は、実際の宣言がどこにあるかにかかわらず、関数の先頭にあるかのように扱われます(関数の外で宣言された場合はグローバルスコープ)。 これは*ホイストと呼ばれます。 ホイストが何をするかを実証するには、次の関数の定義を考慮してください。

```js
function getValue(condition) {

    if (condition) {
        var value = "blue";

        // other code

        return value;
    } else {

        // value exists here with a value of undefined

        return null;
    }

    // value exists here with a value of undefined
}
```

JavaScriptに精通していない場合は、`condition`がtrueと評価された場合にのみ、変数`value`が生成されることを期待するかもしれません。 実際、変数`value`は無関係に生成されます。 背後では、JavaScriptエンジンは`getValue`関数を次のように変更します：

```js
function getValue(condition) {

    var value;

    if (condition) {
        value = "blue";

        // other code

        return value;
    } else {

        return null;
    }
}
```

初期化は同じ場所にとどまる一方で、`value`の宣言は上に上げられます。つまり、変数`value`は実際には`else`節からまだアクセス可能です。そこからアクセスされた場合、変数は初期化されていないため、単に`undefined`の値を持ちます。

新しいJavaScript開発者はしばしばホイストを宣言するのに慣れるために時間がかかることがあり、このユニークな振る舞いを誤解するとバグが発生する可能性があります。このため、ECMAScript6ではブロックレベルのスコープオプションが導入され、変数のライフサイクルをより強力に制御します。

## ブロックレベルの宣言

ブロックレベルの宣言は、指定されたブロックスコープ外でアクセスできない変数を宣言するものです。レキシカルスコープとも呼ばれるブロックスコープが生成されます。

1.関数の内部
1.ブロックの内側(`{`と`}`文字で示される)

ブロックスコープとは、いくつのC言語が動作するかを表し、ECMAScript6でブロックレベルの宣言を導入することは、JavaScriptに同じ柔軟性(均一性)をもたらすことを意図しています。

### 宣言をしよう

`let`宣言シンタックスは`var`のシンタックスと同じです。基本的に`var`を`let`と置き換えて変数を宣言できますが、変数のスコープを現在のコードブロックだけに制限することができます。`let`宣言は囲みブロックの上端に掛けられないので、ブロック内で`let`宣言を最初に置いてブロック全体で使用できるようにしたいかもしれません。ここに例があります：

```js
function getValue(condition) {

    if (condition) {
        let value = "blue";

        // other code

        return value;
    } else {

        // value doesn't exist here

        return null;
    }

    // value doesn't exist here
}
```

このバージョンの`getValue`関数は、他のC言語での期待通りに動作します。 変数`value`は`var`の代わりに`let`を使って宣言されているので、宣言は関数定義の先頭に持ち込まれず、変数`value`は`if`ブロック。`condition`がfalseと評価された場合、`value`は決して宣言されたり初期化されません。

### 再宣言なし

識別子が既にスコープ内に定義されている場合、そのスコープ内の`let`宣言で識別子を使用すると、エラーがスローされます。 例えば：

```js
var count = 30;

// Syntax error
let count = 40;
```

この例では、`count`は`var`で1回、`let`で2回宣言されます。`let`はすでに同じスコープ内に存在する識別子を再定義しないので、`let`宣言はエラーを投げます。 一方、`let`宣言が、次のコードに示すように、変数を含むスコープ内の変数と同じ名前の新しい変数を生成すると、エラーはスローされません。

```js
var count = 30;

// Does not throw an error
if (condition) {

    let count = 40;

    // more code
}
```

この`let`宣言は、周辺ブロックに`count`を生成するのではなく、`if`ステートメント内に`count`という新しい変数を生成するので、エラーを投げません。`if`ブロックの中で、この新しい変数はグローバル`count`をシャドーし、実行がブロックを離れるまでそれにアクセスするのを防ぎます。

### 定数宣言

また、ECMAScript6の変数を`const`宣言シンタックスで定義することもできます。`const`を使って宣言された変数は*定数とみなされます。つまり、一度設定した値を変更することはできません。 このため、次の例のように、すべての`const`変数は宣言時に初期化されなければなりません：

```js
// Valid constant
const maxItems = 30;

// Syntax error: missing initialization
const name;
```

`maxItems`変数は初期化されているので、`const`宣言は問題なく動作するはずです。 しかし、`name`変数は、`name`が初期化されていないので、このコードを含むプログラムを実行しようとするとシンタックスエラーを引き起こします。


#### 定数とvs宣言

`let`宣言のような定数は、ブロックレベルの宣言です。 つまり、この例で示すように、宣言されたブロックから実行が流れ出ても、定数にアクセスできなくなり、宣言は引き上げられません。

```js
if (condition) {
    const maxItems = 5;

    // more code
}

// maxItems isn't accessible here
```

このコードでは、定数`maxItems`は`if`文の中で宣言されています。 ステートメントの実行が終了すると、`maxItems`はそのブロックの外部からアクセスできません。

`let`との別の類似点では、`const`宣言は、同じスコープ内の既に定義された変数の識別子で作られたときにエラーを投げます。 変数が`var`(グローバルスコープまたは関数スコープ)または`let`(ブロックスコープ)を使って宣言されているかどうかは関係ありません。 たとえば、次のコードを考えてみましょう。

```js
var message = "Hello!";
let age = 25;

// Each of these would throw an error.
const message = "Goodbye!";
const age = 30;
```

2つの`const`宣言は単独で有効ですが、前の`var`宣言と`let`宣言が与えられていれば、意図したとおりに動作しません。

これらの類似点にもかかわらず、letとconstの間には大きな違いが1つあります。 前に定義された定数に`const`を代入しようとすると、strictモードとnon-strictモードの両方でエラーがスローされます：

```js
const maxItems = 5;

maxItems = 6;      // throws error
```

他の言語の定数と同様に、`maxItems`変数には後で新しい値を代入することはできません。 ただし、他の言語の定数とは異なり、定数が保持する値はオブジェクトであれば変更できます。

#### Constでオブジェクトを宣言する

`const`宣言は、値そのものではなくバインディングの変更を防ぎます。 つまり、オブジェクトの`const`宣言はそれらのオブジェクトの変更を妨げません。 例えば：

```js
const person = {
    name: "Nicholas"
};

// works
person.name = "Greg";

// throws an error
person = {
    name: "Greg"
};
```

他の言語の定数と同様に、`maxItems`変数には後で新しい値を代入することはできません。他の言語の定数とは異なる、定数を保持する値はオブジェクトでありば変更できます 。

#### Constでオブジェクトを宣言する

`const`宣言は、値そのものではないバイインディングの変更を防ぎます。つまり、オブジェクトの`const`宣言はそれのオブジェクトの変更を妨げません。例えば：

```js
if (condition) {
    console.log(typeof value);  // ReferenceError!
    let value = "blue";
}
```

ここで、変数`value`は`let`を使って定義され初期化されますが、その行は前の行がエラーを投げるため実行されません。問題は、JavaScriptコミュニティが* Temporary Dead Zone *(TDZ)と呼ばれるものに「価値」が存在することです。 TDZはECMAScript仕様では明示的に指定されていませんが、letとconstの宣言が宣言の前にアクセスできない理由を記述するためによく使われます。このセクションでは、TDZの原因となる宣言配置の微妙な部分について説明します。すべての例では`let`を使用していますが、同じ情報が`const`にも適用されます。

JavaScriptエンジンが次のブロックを調べて変数宣言を見つけると、その宣言を関数またはグローバルスコープの先頭(`var`の場合)に持ち上げるか、宣言をTDZに置きます(`let`と`const '`)。 TDZ内の変数にアクセスしようとすると、実行時エラーが発生します。この変数はTDZからのみ削除されるため、実行が変数宣言に移行すると安全に使用できます。

これは、定義される前に`let`または`const`で宣言された変数を使用しようとするたびに当てはまります。上の例が示したように、これは通常安全な`typeof`演算子にも当てはまります。しかし、その変数が宣言されているブロックの外にある変数に`typeof`を使用することはできますが、後で結果を返すことはできません。このコードを考えてみましょう：

```js
console.log(typeof value);     // "undefined"

if (condition) {
    let value = "blue";
}
```

変数`value`は、`value`が宣言されているブロックの外で発生するため、`typeof`演算が実行されるときTDZにありません。 これは`value`バインディングがないことを意味し、`typeof`は単に``undefined``を返します。

TDZはブロックバインディングのユニークな側面の1つに過ぎません。 別のユニークな側面は、ループの内部での使用と関係しています。

## ループ内のブロックバインディング

おそらく、開発者がブロックレベルの変数スコープを最も必要とする領域の1つは、forawayループの中にあります。ここで、throwawayカウンタ変数はループ内でのみ使用されることを意図しています。 たとえば、次のようなコードをJavaScriptで見ることは珍しいことではありません。

```js
for (var i = 0; i < 10; i++) {
    process(items[i]);
}

// i is still accessible here
console.log(i);                     // 10
```

ブロックレベルスコープがデフォルトである他の言語では、この例は意図したとおりに動作し、`for`ループのみが`i`変数にアクセスする必要があります。 しかし、JavaScriptでは、変数`i`は、`var`宣言が呼び出されるので、ループが完了した後も引き続きアクセス可能です。 次のコードのように`let`を使用すると、意図した動作が得られるはずです：

```js
for (let i = 0; i < 10; i++) {
    process(items[i]);
}

// i is not accessible here - throws an error
console.log(i);
```

この例では、変数`i`は`for`ループ内にのみ存在します。 ループが完了すると、変数は他の場所からアクセスできなくなります。

### ループ内の関数

`var`の特性は、ループ変数がループの範囲外からアクセス可能であるため、長い間、ループ内部で関数を生成することに問題がありました。 次のコードを考えてみましょう：

```js
var funcs = [];

for (var i = 0; i < 10; i++) {
    funcs.push(function() { console.log(i); });
}

funcs.forEach(function(func) {
    func();     // outputs the number "10" ten times
});
```

通常、このコードでは0から9までの数字を印刷することが期待されますが、数字10を10回続けて出力します。 これは、`i`がループの各繰り返しで共有されるためです。つまり、ループ内で生成された関数はすべて同じ変数への参照を保持します。 ループが完了すると、変数`i`は`10`の値を持ち、`console.log(i)`が呼び出されるとその値が毎回出力されます。

この問題を解決するために、開発者は直ちに呼び出される関数式(IIFE)をループ内で使用し、この例のように反復処理する変数の新しいコピーを強制的に生成します。

```js
var funcs = [];

for (var i = 0; i < 10; i++) {
    funcs.push((function(value) {
        return function() {
            console.log(value);
        }
    }(i)));
}

funcs.forEach(function(func) {
    func();     // outputs 0, then 1, then 2, up to 9
});
```

このバージョンでは、ループの内部にIIFEが使用されます。`i`変数はIIFEに渡され、独自のコピーが生成され、`value`として格納されます。 これは、その反復の関数が使用する値です。ループが0から9までカウントアップするので、各関数を呼び出すと期待される値が返されます。幸いにも、ECMAScript6の`let`と`const`を使ったブロックレベルのバインディングは、 あなたのためのループ。

### ループ内の宣言を許可する

`let`宣言は、前の例でIIFEが行うことを効果的に模倣することによってループを単純化します。 ループが繰り返されるたびに、新しい変数が生成され、以前の繰り返しと同じ名前の変数の値に初期化されます。 つまり、IIFEを完全に省略し、期待どおりの結果を得ることができます。

```js
var funcs = [];

for (let i = 0; i < 10; i++) {
    funcs.push(function() {
        console.log(i);
    });
}

funcs.forEach(function(func) {
    func();     // outputs 0, then 1, then 2, up to 9
})
```

このループは`var`とIIFEを使ったループとまったく同じように動作しますが、間違いなくクリーンです。`let`宣言は、ループのたびに新しい変数`i`を生成するので、ループ内で生成された各関数は`i`のコピーを取得します。`i`の各コピーは、それが生成されたループ反復の始めに割り当てられた値を持ちます。 以下に示すように、for-inとfor-ofのループについても同じことが言えます：

```js
var funcs = [],
    object = {
        a: true,
        b: true,
        c: true
    };

for (let key in object) {
    funcs.push(function() {
        console.log(key);
    });
}

funcs.forEach(function(func) {
    func();     // outputs "a", then "b", then "c"
});
```

この例では、`for-in`ループは`for`ループと同じ動作を示します。ループを通るたびに、結合新しい`key`が生成され、その各機能は`key`変数の独自のコピーを持っています。その結果、各関数は異なる値を出力します。`var`を使って`key`を宣言すると、すべての関数は``c``を出力します。

I>ループ内の`let`宣言の振る舞いは、仕様では特別に定義された振る舞いであり、必ずしも`let`の非巻上げ特性には関係しないことを理解することが重要です。実際、`let`の初期の実装は、後でプロセスに追加されたので、この動作をしませんでした。

### ループ内の定数宣言

ECMAScript6仕様では、ループ内の`const`宣言を明示的に禁止していません。しかし、使用しているループのタイプに基づいて異なる動作があります。通常の`for`ループでは、イニシャライザで`const`を使うことができますが、値を変更しようとするとループは警告を出します。例えば：

```js
var funcs = [];

// throws an error after one iteration
for (const i = 0; i < 10; i++) {
    funcs.push(function() {
        console.log(i);
    });
}
```

このコードでは、`i`変数は定数として宣言されています。 ループの最初の反復(`i`が0)は正常に実行されます。`i ++`が定数を変更しようとしているときに実行すると、エラーがスローされます。 したがって、変数を変更していない場合は、ループ初期化子で変数を宣言するためにのみ`const`を使用することができます。

一方、for-forやfor-ofループで使用された場合、const変数はlet変数と同じように動作します。 したがって、次のようなエラーは発生しません。

```js
var funcs = [],
    object = {
        a: true,
        b: true,
        c: true
    };

// doesn't cause an error
for (const key in object) {
    funcs.push(function() {
        console.log(key);
    });
}

funcs.forEach(function(func) {
    func();     // outputs "a", then "b", then "c"
});
```

このコードは、「ループ内の宣言をする」セクションの2番目の例とほぼ同じように機能します。 唯一の違いは、`key`の値はループ内で変更できないということです。`for-in`と`for-of`ループは`const`と連動します。なぜなら、ループ初期化子は既存のバインディングの値を変更しようとするのではなく、ループを通して各反復に新しいバインディングを生成するからです。 前の例では`for-in`の代わりに`for`を使用しています)。

## グローバルブロックバインディング

`let`と`const`が`var`と違うもう一つの方法はグローバルスコープの振る舞いです。 グローバルスコープで`var`が使われると、グローバルオブジェクト(ブラウザーの`window`)のプロパティーである新しいグローバル変数が生成されます。 つまり、誤って既存のグローバルを`var`を使って上書きすることができます：

```js
// in a browser
var RegExp = "Hello!";
console.log(window.RegExp);     // "Hello!"

var ncz = "Hi!";
console.log(window.ncz);        // "Hi!"
```

`RegExp`グローバルは`window`で定義されていますが、`var`宣言によって上書きされることから安全ではありません。 この例では、オリジナルを上書きする新しいグローバル変数`RegExp`が宣言されています。 同様に、`ncz`はグローバル変数として定義され、すぐに`window`のプロパティとして定義されます。 これは、JavaScriptが常に機能する方法です。

代わりにグローバルスコープで`let`または`const`を使うと、グローバルスコープに新しいバインディングが生成されますが、グローバルオブジェクトにはプロパティは追加されません。 これは、`let`や`const`を使ってグローバル変数を上書きすることもできないことを意味します。 ここに例があります：

```js
// in a browser
let RegExp = "Hello!";
console.log(RegExp);                    // "Hello!"
console.log(window.RegExp === RegExp);  // false

const ncz = "Hi!";
console.log(ncz);                       // "Hi!"
console.log("ncz" in window);           // false
```

ここで、`RegExp`の新しい`let`宣言は、グローバル`RegExp`をシャドーするバインディングを生成します。つまり、`window.RegExp`と`RegExp`は同じではないので、グローバルスコープに混乱はありません。また、`ncz`の`const`宣言はバインディングを生成しますが、グローバルオブジェクトにはプロパティを生成しません。この機能により、グローバルオブジェクトにプロパティを生成したくない場合に、グローバルスコープ内で使用するために、`let`と`const`をより安全にすることができます。

I>グローバルオブジェクトから利用できるコードがあれば、グローバルスコープで`var`を使いたいかもしれません。これは、フレームやウィンドウ間でコードにアクセスする場合に、ブラウザで最も一般的です。

## ブロックバインディングの新しいベストプラクティス

ECMAScript6は開発中でしたが、変数宣言に`var`の代わりに`let`を使うべきではないかという考えが広まっていました。多くのJavaScript開発者にとって、`let`は`var`が振る舞っていたはずのやり方とまったく同じように振る舞います。したがって、直接置換は論理的に意味があります。この場合、変更保護が必要な変数には`const`を使います。

しかし、より多くの開発者がECMAScript6に移行するにつれ、別のアプローチが普及しました。デフォルトでは`const`を使用し、変数の値を変更する必要があることを知っているときは`let`を使用します。その根拠は、予期しない値の変更がバグの原因であるため、ほとんどの変数が初期化後に値を変更してはならないということです。このアイディアには大きな牽引力があり、ECMAScript6を採用する際には、コード内で検討する価値があります。

## まとめ

`let`ブロックと`const`ブロックバインディングは、JavaScriptに字句的なスコープを導入します。これらの宣言はホイストされず、宣言されたブロック内にのみ存在します。これは、他の言語に似ていて、誤って意図しないエラーが発生する可能性が低い動作を提供するため、変数が必要な場所で正確に宣言できるようになりました。副作用として、`typeof`のような安全な演算子であっても、宣言される前に変数にアクセスすることはできません。宣言の前にブロックバインディングにアクセスしようとすると、バインディングが一時的な不感帯(TDZ)に存在するためにエラーが発生します。

多くの場合、`let`と`const`は`var`と同じように動作します。しかし、これはループには当てはまりません。`let`と`const`の両方に対して、for-inとfor-ofのループは、ループを通る各反復で新しいバインディングを生成します。つまり、ループ本体の内部で生成された関数は、ループの最終反復(`var`を使った動作)の後であったのではなく、現在の反復中にループバインディング値にアクセスできます。`for`ループの`let`宣言でも同じことが言えますが、`for`ループで`const`宣言を使用しようとするとエラーが発生する可能性があります。

ブロックバインディングの現在のベストプラクティスは、デフォルトで`const`を使用し、変数の値を変更する必要があることを知っているときだけ`let`を使用することです。これにより、特定の種類のエラーを防ぐのに役立つコードの不変性の基本レベルが保証されます。


