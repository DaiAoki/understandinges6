# セットとマップ

JavaScriptはその歴史の大部分で`Array`型で表現されたコレクションの1種類しか持っていませんでした(配列以外のオブジェクトはすべてキーと値のペアの集合であると主張するかもしれませんが、 )。配列は他の言語の配列と同じようにJavaScriptでも使用されていますが、他のコレクションオプションがないため配列はしばしば待ち行列やスタックとして使われていました。配列は数値インデックスのみを使用するため、非数値インデックスが必要な場合はいつでも、非配列オブジェクトが使用されました。この手法では、配列以外のオブジェクトを使用したセットやマップのカスタム実装が可能になりました。

A * set *は、重複を含むことができない値のリストです。通常は、配列内のアイテムと同じように、セット内の個々のアイテムにはアクセスしません。代わりに、値が存在するかどうかを調べるためにセットをチェックするほうがはるかに一般的です。 *マップ*は、特定の値に対応するキーの集合です。そのため、マップ内の各アイテムには2つのデータが格納され、読み取るキーを指定することによって値が取得されます。マップはキャッシュとして頻繁に使用され、すぐに後で検索されるデータを格納するために使用されます。 ECMAScript5には正式なセットとマップはありませんでしたが、開発者は配列以外のオブジェクトを使用してこの制限を回避しました。

ECMAScript6では、JavaScriptにセットとマップが追加されました。この章では、これらの2つのコレクションタイプについて知る必要があるすべてについて説明します。

まず、ECMAScript6の前にセットとマップを実装するために使用した開発者の回避策と、その実装がなぜ問題であったのかについて説明します。その重要な背景情報の後、ECMAScript6でセットとマップがどのように機能するかについて説明します。

## ECMAScript5のセットとマップ

ECMAScript5では、以下のようなオブジェクトプロパティを使用して、セットとマップを模倣しました。

```js
let set = Object.create(null);

set.foo = true;

// checking for existence
if (set.foo) {

    // do something
}
```

この例の`set`変数は`null`プロトタイプを持つオブジェクトで、オブジェクトに継承されたプロパティがないことを保証します。 オブジェクトプロパティをチェックする一意の値として使用するのは、ECMAScript5の一般的なアプローチです。プロパティが`set`オブジェクトに追加されると、それは`true`に設定され、条件文(この例の`if`ステートメント )は、その値が存在するかどうかを簡単にチェックできます。

セットとして使用されるオブジェクトとマップとして使用されるオブジェクトの唯一の実際の違いは、格納される値です。 たとえば、次の例ではオブジェクトをマップとして使用しています。

```js
let map = Object.create(null);

map.foo = "bar";

// retrieving a value
let value = map.foo;

console.log(value);         // "bar"
```

このコードはキー`foo`の下に文字列値``bar"を格納します。 セットとは異なり、マップは主にキーの存在をチェックするのではなく、情報を取得するために使用されます。

## 回避策の問題

単純な状況では、オブジェクトをセットやマップとして使用するのは問題ありませんが、オブジェクトのプロパティの制限を踏まえれば、そのアプローチは複雑になります。 たとえば、すべてのオブジェクトのプロパティは文字列でなければならないため、同じ文字列に対して2つのキーが評価されないことを確認する必要があります。 次の点を考慮してください。

```js
let map = Object.create(null);

map[5] = "foo";

console.log(map["5"]);      // "foo"
```

この例では、文字列値``foo '`を数値キー' 5 'に代入します。 内部的には、その数値は文字列に変換されるので、`map [" 5 "]`と`map [5]`は実際に同じプロパティを参照します。 その内部変換は、数字と文字列の両方をキーとして使用する場合に問題を引き起こす可能性があります。 次のようにオブジェクトをキーとして使用すると、別の問題が発生します。

```js
let map = Object.create(null),
    key1 = {},
    key2 = {};

map[key1] = "foo";

console.log(map[key2]);     // "foo"
```

ここで`map [key2]`と`map [key1]`は同じ値を参照します。 オブジェクトのプロパティは文字列でなければならないので、オブジェクト`key1`と`key2`は文字列に変換されます。``[object Object]``はオブジェクトのデフォルト文字列表現であるため、`key1`と`key2`の両方がその文字列に変換されます。 これは、異なるオブジェクトキーが実際は異なっていると仮定することが論理的であるため、明らかではないエラーを引き起こす可能性があります。

デフォルトの文字列表現に変換すると、オブジェクトをキーとして使用するのが難しくなります。 (オブジェクトをセットとして使用しようとするときにも同じ問題があります)。

値が偽であるキーを持つ地図は、それ自身の特定の問題も示します。`if`ステートメントのようなブール値が必要な状況で使用されると、偽の値は自動的にfalseに変換されます。 この変換だけでも問題はありません。値を使用する方法については慎重でなければなりません。 たとえば、次のコードを見てください。

```js
let map = Object.create(null);

map.count = 1;

// checking for the existence of "count" or a nonzero value?
if (map.count) {
    // ...
}
```

この例では`map.count`の使い方があいまいです。`if`文は`map.count`の存在をチェックすることを意図していますか、またはその値が非ゼロであるか？値1が真実であるため、`if`ステートメント内のコードが実行されます。しかし、`map.count`が0の場合、`map.count`が存在しない場合、`if`文内のコードは実行されません。

これらは、大規模なアプリケーションで発生したときに識別してデバッグするのが困難な問題です。これは、ECMAScript6がセットとマップの両方を言語に追加する主な理由です。

I> JavaScriptには、オブジェクトの値を読み取らずにオブジェクトにプロパティが存在する場合に`true`を返す`in`演算子があります。しかし、`in`演算子はオブジェクトのプロトタイプも検索するので、オブジェクトが`null`プロトタイプを持つときにのみ安全に使うことができます。それでも、多くの開発者は`in 'を使用するのではなく、最後の例のようにコードを誤って使用しています。

## ECMAScript6のセット

ECMAScript6は重複のない値の順序付きリストである`Set`型を追加します。セットを使用すると、含まれているデータにすばやくアクセスでき、離散値をより効率的にトラッキングできます。

### セットの作成と項目の追加

セットは`new Set()`で作成され、アイテムは`add()`メソッドを呼び出してセットに追加されます。`size`プロパティをチェックすると、セット内にいくつのアイテムがあるかを見ることができます：

```js
let set = new Set();
set.add(5);
set.add("5");

console.log(set.size);    // 2
```

setは、値が同じかどうかを判断するために値を強制しません。 つまり、セットには、数字`5`と文字列`5`が2つの別個のアイテムとして含まれることがあります。 (唯一の例外は、-0と+0は同じものとみなされます)。複数のオブジェクトをセットに追加することもできます。これらのオブジェクトは別々のままです。

```js
let set = new Set(),
    key1 = {},
    key2 = {};

set.add(key1);
set.add(key2);

console.log(set.size);    // 2
```

`key1`と`key2`は文字列に変換されないので、セット内の2つの一意の項目として数えられます。 (文字列に変換された場合、それらは両方とも["Object object]"`と等しくなります)。

`add()`メソッドが同じ値で複数回呼び出された場合、最初の呼び出しの後のすべての呼び出しは実質的に無視されます：

```js
let set = new Set();
set.add(5);
set.add("5");
set.add(5);     // duplicate - this is ignored

console.log(set.size);    // 2
```

配列を使用してセットを初期化することができ、`Set`コンストラクタは一意の値だけが使用されることを保証します。 例えば：

```js
let set = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
console.log(set.size);    // 5
```

この例では、重複値を持つ配列を使用してセットを初期化します。 数字`5`は配列内に4回現れていてもセット内に1回しか現れません。 この機能により、既存のコードまたはJSON構造を簡単に使用できるように変換できます。

I>`Set`コンストラクタは実際に反復可能オブジェクトを引数として受け取ります。 配列は、セットやマップと同じように、デフォルトで反復可能であるため動作します。`Set`コンストラクタはイテレータを使って引数から値を抽出します。 (イテラティブルとイテレータについては第8章で詳しく説明しています)

`has()`メソッドを使って、どの値がセットに含まれているかをテストすることができます。

```js
let set = new Set();
set.add(5);
set.add("5");

console.log(set.has(5));    // true
console.log(set.has(6));    // false
```

ここで`set.has(6)`はセットにその値がないのでfalseを返します。

### 値を削除する

セットから値を削除することもできます。`delete()`メソッドを使って単一の値を削除することも、`clear()`メソッドを呼び出すことでその集合からすべての値を削除することもできます。 このコードは両方の動作を示しています：

```js
let set = new Set();
set.add(5);
set.add("5");

console.log(set.has(5));    // true

set.delete(5);

console.log(set.has(5));    // false
console.log(set.size);      // 1

set.clear();

console.log(set.has("5"));  // false
console.log(set.size);      // 0
```

`delete()`呼び出しの後、`5`だけがなくなります。`clear()`メソッドが実行された後、`set`は空です。

これは、一意の順序付けされた値を追跡するための非常に簡単なメカニズムになります。ただし、セットにアイテムを追加して、各アイテムに対して操作を実行する場合はどうなりますか？それは`forEach()`メソッドがあるところです。

### 集合のforEach()メソッド

配列の操作に慣れているなら、既に`forEach()`メソッドに精通しているかもしれません。 ECMAScript5は`forEach()`を配列に追加して、`for`ループを簡単に設定することなく配列の各項目を処理します。このメソッドは開発者に人気があることが判明していますので、同じメソッドをセットで使用でき、同じ方法で動作します。

`forEach()`メソッドには、3つの引数を受け入れるコールバック関数が渡されます：

1.セット内の次の位置からの値
1.第1引数と同じ値
1.値が読み込まれるセット

`forEach()`のセットバージョンと配列バージョンとの間の奇妙な違いは、コールバック関数の第1引数と第2引数が同じであることです。これは間違いのように見えるかもしれませんが、その動作には十分な理由があります。

`forEach()`メソッド(配列とマップ)を持つ他のオブジェクトは、3つの引数をコールバック関数に渡します。配列とマップの最初の2つの引数は、値とキー(配列の数値インデックス)です。

ただし、セットにはキーはありません。 ECMAScript6標準の背後にある人々は、`forEach()`のsetバージョンでコールバック関数を2つの引数を受け入れることができましたが、それは他の2つの引数と異なったでしょう。代わりに、コールバック関数を同じに保ち、3つの引数を受け入れる方法を見つけました。セット内の各値は、キーと値の両方であるとみなされます。そのため、第1引数と第2引数は、配列とマップ上の他の`forEach()`メソッドと一貫性を保つために、`forEach()`とセットで常に同じです。

引数の違い以外にも、`forEach()`を使うのは、基本的には配列の場合と同じです。方法を示すコードは次のとおりです。

```js
let set = new Set([1, 2]);

set.forEach(function(value, key, ownerSet) {
    console.log(key + " " + value);
    console.log(ownerSet === set);
});
```

このコードは、セット内の各項目を繰り返し処理し、`forEach()`コールバック関数に渡された値を出力します。 コールバック関数が実行されるたびに、`key`と`value`は同じで、`ownerSet`は常に`set`と等しくなります。 このコードは次を出力します：

```
1 1
true
2 2
true
```

配列と同じように、コールバック関数で`this`を使用する必要がある場合は`forEach()`の2番目の引数として`this`の値を渡すことができます：

```js
let set = new Set([1, 2]);

let processor = {
    output(value) {
        console.log(value);
    },
    process(dataSet) {
        dataSet.forEach(function(value) {
            this.output(value);
        }, this);
    }
};

processor.process(set);
```

この例では、`processor.process()`メソッドはセット上で`forEach()`を呼び出し、`this`をコールバックの`this`値として渡します。 これは必要なので`this.output()`は`processor.output()`メソッドに正しく解決されます。`forEach()`コールバック関数は最初の引数`value`だけを利用するので、他の引数は省略されます。 矢印関数を使って、次のように2番目の引数を渡さなくても同じ効果を得ることができます：

```js
let set = new Set([1, 2]);

let processor = {
    output(value) {
        console.log(value);
    },
    process(dataSet) {
        dataSet.forEach((value) => this.output(value));
    }
};

processor.process(set);
```

この例のarrow関数は`process()`関数から`this`を読み込み、`this.output()`を`processor.output()`呼び出しに正しく解決するはずです。

セットは値をトラッキングするのに適していますが、`forEach()`は各値を順番に処理できるため、配列のようにインデックスで直接値にアクセスすることはできません。 そうする必要がある場合は、セットを配列に変換することをお勧めします。

### セットを配列に変換する

配列を`Set`コンストラクタに渡すことができるので、配列をセットに変換するのは簡単です。 スプレッド演算子を使用して、セットを配列に変換することも簡単です。 第3章では、配列内の項目を別々の関数パラメータに分割する方法として、スプレッド演算子(`...`)を導入しました。 スプレッド演算子を使用して、セットなどの反復可能オブジェクトを配列に変換することもできます。 例えば：

```js
let set = new Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);             // [1,2,3,4,5]
```

ここでは、最初にセットに重複を含む配列がロードされます。 セットは重複を削除し、アイテムはスプレッド演算子を使用して新しい配列に配置されます。 セット自体には、作成時に受け取った項目(`1`,`2`,`3`,`4`,`5`)がまだ含まれています。 彼らは新しい配列にコピーされました。

この方法は、すでに配列を持っていて、重複のない配列を作成する場合に便利です。 例えば：

```js
function eliminateDuplicates(items) {
    return [...new Set(items)];
}

let numbers = [1, 2, 3, 3, 3, 4, 5],
    noDuplicates = eliminateDuplicates(numbers);

console.log(noDuplicates);      // [1,2,3,4,5]
```

`eliminateDuplicates()`関数では、重複していない新しい配列を作成する前に重複した値をフィルタリングするために使用される一時的な仲介者にすぎません。

### 弱いセット

`Set`型は、オブジェクト参照を格納する方法のために、強集合とも呼ばれます。`Set`のインスタンスに格納されたオブジェクトは、そのオブジェクトを変数の中に格納するのと事実上同じです。 その`Set`インスタンスへの参照が存在する限り、オブジェクトはメモリを解放するためにガベージコレクトされることはできません。 例えば：

```js
let set = new Set(),
    key = {};

set.add(key);
console.log(set.size);      // 1

// eliminate original reference
key = null;

console.log(set.size);      // 1

// get the original reference back
key = [...set][0];
```

この例では、`key`を`null`に設定すると、`key`オブジェクトの一つの参照がクリアされますが、`set`の中に別のリファレンスが残っています。セットを、スプレッド演算子で配列に変換し、最初の項目にアクセスすることによって、`key`を引き出すことができます。その結果はほとんどのプログラムにとっては問題ありませんが、他のすべての参照が消えると、セット内の参照が消えるほうがよい場合もあります。たとえば、JavaScriptコードがWebページで実行されていて、別のスクリプトによって削除される可能性のあるDOM要素を追跡したい場合は、DOM要素への最後の参照にコードを保持しないようにします。 (そのような状況を*メモリリーク*と呼びます。)

このような問題を軽減するために、ECMAScript6には弱いオブジェクト参照のみを格納し、プリミティブ値を格納できない*弱集合*も含まれています。オブジェクトへの*弱参照*は、残っている唯一の参照であればガベージコレクションを妨げません。

#### 弱い集合を作る

WeakSetは`WeakSet`コンストラクタを使って作成され、`add()`メソッド、`has()`メソッド、`delete()`メソッドを持っています。ここでは3つすべてを使用する例を示します。

```js
let set = new WeakSet(),
    key = {};

// add the object to the set
set.add(key);

console.log(set.has(key));      // true

set.delete(key);

console.log(set.has(key));      // false
```

弱いセットを使うのは、普通のセットを使うのと似ています。 ウィークセット内の参照を追加、削除、およびチェックすることができます。 反復可能な値をコンストラクタに渡すことによって、弱い集合に値をシードすることもできます。

```js
let key1 = {},
    key2 = {},
    set = new WeakSet([key1, key2]);

console.log(set.has(key1));     // true
console.log(set.has(key2));     // true
```

この例では、配列は`WeakSet`コンストラクタに渡されます。 この配列には2つのオブジェクトが含まれているため、それらのオブジェクトは弱い集合に追加されます。`WeakSet`はプリミティブ値を受け入れることができないので、配列にオブジェクト以外の値が含まれていると、エラーがスローされます。

#### セットタイプの主な相違点

ウィークセットと通常セットの最大の違いは、オブジェクト値に保持されているウィークリファレンスです。 その違いを示す例を次に示します。

```js
let set = new WeakSet(),
    key = {};

// add the object to the set
set.add(key);

console.log(set.has(key));      // true

// remove the last strong reference to key, also removes from weak set
key = null;
```

このコードが実行されると、ウィークセット内の`key`への参照にアクセスできなくなります。`has()`メソッドに渡すためにそのオブジェクトへの参照が1つ必要となるため、その削除を検証することはできません。これは、弱いテストのテストを少し混乱させる可能性がありますが、JavaScriptエンジンによってリファレンスが適切に削除されたと信じることができます。

これらの例は、弱いセットがいくつかの特性を通常のセットと共有していることを示していますが、いくつかの重要な違いがあります。それらは：

1.`WeakSet`インスタンスでは、非オブジェクト引数(`has()`と`delete()`が渡されたときに、`add()`メソッドはエラーを投げます。
1.弱いセットはiterableではないので、`for-of`ループでは使用できません。
弱いセットは反復子(`keys()`や`values()`メソッドなど)を公開しないので、弱集合の内容をプログラムで決定する方法はありません。
1.弱いセットは`forEach()`メソッドを持たない。
1.弱いセットは`size`プロパティを持たない。

メモリを適切に処理するためには、弱いセットの一見限られた機能が必要です。一般に、オブジェクト参照のみを追跡する必要がある場合は、通常のセットではなく弱いセットを使用する必要があります。

セットは値のリストを扱う新しい方法を提供しますが、追加の情報をそれらの値に関連付ける必要がある場合は役に立ちません。 ECMAScript6ではマップも追加されています。

## ECMAScript6のマップ

ECMAScript6`Map`型は、キーと値のペアの順序付けられたリストです。ここでは、キーと値の両方が任意の型を持つことができます。キーの同値性は、`Set`オブジェクトと同じアプローチを使用することによって決定されます。したがって、キーの種類が異なるので、キーの値が`5`で、キーの値が`5`です。これは、オブジェクトプロパティが常に値を文字列に強制するので、オブジェクトプロパティをキーとして使用するのとはまったく異なります。

マップにアイテムを追加するには、`set()`メソッドを呼び出して、キーとそのキーに関連付ける値を渡します。キーを`get()`メソッドに渡すことで、後で値を取得できます。例えば：

```js
let map = new Map();
map.set("title", "Understanding ES6");
map.set("year", 2016);

console.log(map.get("title"));      // "Understanding ES6"
console.log(map.get("year"));       // 2016
```

この例では、2つのキーと値のペアが格納されています。``title "`キーは文字列を格納し、``year "``キーは数値を格納します。`get()`メソッドは後で呼び出され、両方のキーの値を取得します。 いずれかのキーがマップに存在しない場合、`get()`は値の代わりに特別な値`undefined`を返していました。

また、オブジェクトをキーとして使用することもできます。これは、オブジェクトのプロパティを使用して古い対処法でマップを作成する場合は不可能です。 ここに例があります：

```js
let map = new Map(),
    key1 = {},
    key2 = {};

map.set(key1, 5);
map.set(key2, 42);

console.log(map.get(key1));         // 5
console.log(map.get(key2));         // 42
```

このコードでは、マップ内のキーとして`key1`と`key2`オブジェクトを使用して、2つの異なる値を格納します。 これらのキーは別のフォームに強制されないため、各オブジェクトは一意であるとみなされます。 これにより、オブジェクト自体を変更することなく、追加のデータをオブジェクトに関連付けることができます。

マップメソッド

マップはいくつかのメソッドをセットと共有します。 これは意図的なもので、同様の方法でマップやセットと対話することができます。 これらの3つの方法は、マップとセットの両方で利用できます。

*`has(key)`- 指定されたキーがマップに存在するかどうかを判定します
*`delete(key)`- キーとそれに関連する値をマップから削除する
*`clear()`- すべてのキーと値をマップから削除します。

マップには、それに含まれるキーと値のペアの数を示す`size`プロパティもあります。 このコードでは、3つのメソッドと`size`メソッドの使い方が異なります。

```js
let map = new Map();
map.set("name", "Nicholas");
map.set("age", 25);

console.log(map.size);          // 2

console.log(map.has("name"));   // true
console.log(map.get("name"));   // "Nicholas"

console.log(map.has("age"));    // true
console.log(map.get("age"));    // 25

map.delete("name");
console.log(map.has("name"));   // false
console.log(map.get("name"));   // undefined
console.log(map.size);          // 1

map.clear();
console.log(map.has("name"));   // false
console.log(map.get("name"));   // undefined
console.log(map.has("age"));    // false
console.log(map.get("age"));    // undefined
console.log(map.size);          // 0

```

セットと同様に、`size`プロパティーは常にマップ内のキーと値のペアの数を含みます。 この例の``Map``インスタンスは``名前 '`と``age"`キーで始まります。したがって、どちらのキーも渡されたときに`has()`は`true`を返します。``delete()`メソッドによって``name"`キーが削除された後、``has()``メソッドは``name"`が渡されると`false`を返し、`size`プロパティはアイテムが1つ少ないことを示します。 次に`clear()`メソッドは、残りのキーを削除します。これは、`has()`が両方のキーに`false`を返し、`size`が0になります。

`clear()`メソッドは、マップから多くのデータを削除するための速い方法ですが、一度に多くのデータをマップに追加する方法もあります。

### 地図の初期化

また、セットに似て、`Map`コンストラクタに配列を渡すことで、データでマップを初期化することができます。 配列内の各項目は、最初の項目がキーで、2番目がそのキーの対応する値である配列でなければなりません。 したがって、マップ全体は、次のような2項目の配列の配列です。

```js
let map = new Map([["name", "Nicholas"], ["age", 25]]);

console.log(map.has("name"));   // true
console.log(map.get("name"));   // "Nicholas"
console.log(map.has("age"));    // true
console.log(map.get("age"));    // 25
console.log(map.size);          // 2
```

キー "name"と "age"はコンストラクタの初期化によって`map`に追加されます。 配列の配列はちょっと変わって見えるかもしれませんが、キーはどのデータ型でもよいので、キーを正確に表現する必要があります。 キーを配列に格納することは、マップに格納される前に別のデータ型に強制されないようにするための唯一の方法です。

### 地図上のforEachメソッド

マップの`forEach()`メソッドは、3つの引数を受け取るコールバック関数を受け入れるという点で、セットと配列の`forEach()`に似ています：

1.地図上の次の位置からの値
その値の鍵
1.値が読み込まれるマップ

これらのコールバック引数は、最初の引数が値で、2番目がキー(配列の数値インデックスに対応)である配列の`forEach()`動作とよりよく一致します。 ここに例があります：

```js
let map = new Map([ ["name", "Nicholas"], ["age", 25]]);

map.forEach(function(value, key, ownerMap) {
    console.log(key + " " + value);
    console.log(ownerMap === map);
});
```

`forEach()`コールバック関数は、渡された情報を出力します。`value`と`key`は直接出力され、`ownerMap`は`map`と比較され、値が同等であることが示されます。 これは、

```
name Nicholas
true
age 25
true
```

`forEach()`に渡されたコールバックは、ペアがマップに挿入された順に各キーと値のペアを受け取ります。この動作は配列上で`forEach()`を呼び出すのと少し異なります。コールバックは数値インデックスの順に各項目を受け取ります。

I>`forEach()`に2番目の引数を指定して、コールバック関数内で`this`値を指定することもできます。そのような呼び出しは`forEach()`メソッドの設定されたバージョンと同じように動作します。

### 弱い地図

弱マップは、弱いオブジェクトセットを格納する方法です。 *弱いマップ*では、すべてのキーはオブジェクトでなければならず(非オブジェクトキーを使用しようとするとエラーがスローされます)、これらのオブジェクト参照は弱く保持され、ガベージコレクションを妨げません。弱マップ外の弱マップキーへの参照がない場合、弱マップからキー/値ペアが削除されます。

ウィークマップを使用する最も便利な場所は、Webページ内の特定のDOM要素に関連するオブジェクトを作成するときです。たとえば、Webページ用のJavaScriptライブラリの中には、ライブラリで参照されるすべてのDOM要素に対して1つのカスタムオブジェクトを保持しており、そのマッピングがオブジェクトのキャッシュに内部的に格納されています。

このアプローチの困難な部分は、DOM要素がWebページにもはや存在しなくなった時点を判断して、ライブラリが関連するオブジェクトを削除できるようにすることです。それ以外の場合、ライブラリは参照の有用性を超えてDOM要素参照を保持し、メモリリークを引き起こします。弱いマップでDOM要素を追跡すると、ライブラリはカスタムオブジェクトをすべてのDOM要素に関連付けることができ、オブジェクトのDOM要素が存在しなくなったときにマップ内のオブジェクトを自動的に破棄することができます。

I>弱いマップキーだけで弱いマップ値ではなく弱い参照であることに注意することが重要です。ウィークマップ値として保存されたオブジェクトは、他のすべての参照が削除された場合にガベージコレクションを防止します。

#### 弱マップを使用する

ECMAScript6 WeakMap型は、キーと値のペアの順序付けられていないリストです。ここで、キーはnull以外のオブジェクトでなければならず、値は任意の型でなければなりません。`WeakMap`のインターフェースは`set()`と`get()`がそれぞれデータの追加と検索に使用されているという点でMapのものと非常に似ています：

```js
let map = new WeakMap(),
    element = document.querySelector(".element");

map.set(element, "Original");

let value = map.get(element);
console.log(value);             // "Original"

// remove the element
element.parentNode.removeChild(element);
element = null;

// the weak map is empty at this point
```

この例では、1つのキーと値のペアが格納されています。`element`キーは、対応する文字列値を格納するために使用されるDOM要素です。この値は、DOM要素を`get()`メソッドに渡すことによって取得されます。後でDOM要素がドキュメントから削除され、DOM要素を参照する変数が`null`に設定されると、データも弱いマップから削除されます。

弱いセットと同様に、弱いマップが空であることを確認する方法はありません。なぜなら、それは`size`プロパティを持たないからです。キーへの参照が残っていないので、`get()`メソッドを呼び出すことで値を取得することはできません。弱いマップはそのキーの値へのアクセスを遮断し、ガベージコレクタが実行されると、その値が占めるメモリは解放されます。

#### 弱い地図の初期化

弱いマップを初期化するには、配列の配列を`WeakMap`コンストラクタに渡します。通常のマップを初期化するのと同様に、格納する配列内の各配列は2つの項目を持つ必要があります。最初の項目はnull以外のオブジェクトキーで、2番目の項目は値(任意のデータ型)です。例えば：

```js
let key1 = {},
    key2 = {},
    map = new WeakMap([[key1, "Hello"], [key2, 42]]);

console.log(map.has(key1));     // true
console.log(map.get(key1));     // "Hello"
console.log(map.has(key2));     // true
console.log(map.get(key2));     // 42
```

オブジェクト`key1`と`key2`は弱点マップのキーとして使われ、`get()`と`has()`メソッドはそれらにアクセスできます。`WeakMap`コンストラクタが任意のキーと値のペアで非オブジェクトキーを受け取ると、エラーがスローされます。

#### 弱い地図のメソッド

弱いマップには、キーと値のペアと対話するための2つの追加メソッドしかありません。 指定されたキーがマップに存在するかどうかを判別する`has()`メソッドと、特定のキーと値のペアを削除する`delete()`メソッドがあります。`clear()`メソッドはありません。弱いマップでは不可能な弱いセットのようなキーを列挙する必要があるからです。 この例では、`has()`と`delete()`の両方のメソッドを使います：

```js
let map = new WeakMap(),
    element = document.querySelector(".element");

map.set(element, "Original");

console.log(map.has(element));   // true
console.log(map.get(element));   // "Original"

map.delete(element);
console.log(map.has(element));   // false
console.log(map.get(element));   // undefined
```

ここで、DOM要素は、弱マップ内のキーとして再度使用されます。`has()`メソッドは、参照が弱マップ内のキーとして現在使用されているかどうかを調べるのに役立ちます。 これは、キーへのnull以外の参照がある場合にのみ機能することに注意してください。 キーは、`has()`が`false`を返し、`get()`が`undefined`を返す`delete()`メソッドによって、弱いマップから強制的に削除されます。

#### プライベートオブジェクトデータ

ほとんどの開発者は、弱いマップの主な使用例をDOM要素と関連付けると考えていますが、他にも多くの用途があります(間違いなく、まだ発見されていないものもあります)。 弱いマップの1つの実用的な使用法は、オブジェクトインスタンスに専用のデータを格納することです。 すべてのオブジェクトのプロパティはECMAScript6で公開されているため、オブジェクトにアクセスできるようにするためにいくつかの創造性を使用する必要がありますが、すべてにアクセスすることはできません。 次の例を考えてみましょう。

```js
function Person(name) {
    this._name = name;
}

Person.prototype.getName = function() {
    return this._name;
};
```

このコードでは、先頭のアンダースコアの一般的な規則を使用して、プロパティがプライベートであるとみなされ、オブジェクトインスタンス外で変更されるべきでないことを示します。 その目的は`getName()`を使用して`this._name`を読み込み、`_name`値を変更することを許可しないことです。 しかし、誰かが`_name`プロパティに書き込む途中に立っていることは何もないので、意図的にまたは偶発的に上書きすることはできません。

ECMAScript5では、次のようなパターンを使用してオブジェクトを作成することで、真にプライベートなデータを得ることに近づくことができます。

```js
var Person = (function() {

    var privateData = {},
        privateId = 0;

    function Person(name) {
        Object.defineProperty(this, "_id", { value: privateId++ });

        privateData[this._id] = {
            name: name
        };
    }

    Person.prototype.getName = function() {
        return privateData[this._id].name;
    };

    return Person;
}());
```

この例では、`private`と`privateId`という2つのプライベート変数を含むIIFEに`Person`の定義をラップしています。`privateData`オブジェクトは各インスタンスのプライベート情報を格納し、`privateId`はインスタンスごとに一意のIDを生成するために使用されます。`Person`コンストラクタが呼び出されたときには、設定不可能で、設定不可能で、書き込み不能な`_id`プロパティが追加されます。

次に、オブジェクトインスタンスのIDに対応する`privateData`オブジェクトにエントリが作成されます。そこに`name`が格納されています。後で`getName()`関数で`this._id`を`privateData`のキーとして使うことで名前を取り出すことができます。`privateData`はIIFEの外部ではアクセスできないので、`this._id`が公開されていても、実際のデータは安全です。

このアプローチの大きな問題は、オブジェクトインスタンスがいつ破棄されるかを知る方法がないため、`privateData`のデータが消えないことです。`privateData`オブジェクトは常に余分なデータを含みます。この問題は、次のように弱いマップを代わりに使用することで解決できます。

```js
let Person = (function() {

    let privateData = new WeakMap();

    function Person(name) {
        privateData.set(this, { name: name });
    }

    Person.prototype.getName = function() {
        return privateData.get(this).name;
    };

    return Person;
}());
```

このバージョンの`Person`サンプルは、オブジェクトではなくプライベートデータの弱いマップを使います。`Person`オブジェクトのインスタンス自体をキーとして使うことができるので、別のIDを追跡する必要はありません。`Person`コンストラクタが呼び出されると、`this`のキーとプライベート情報を含むオブジェクトの値を持つ弱いマップに新しいエントリが作成されます。この場合、その値は`name`だけを含むオブジェクトです。`getName()`関数は、`this`を`privateData.get()`メソッドに渡すことによってそのプライベート情報を取得します。このメソッドは、値オブジェクトを取り出し、`name`プロパティにアクセスします。この手法は、プライベート情報をプライベートに保ち、それに関連付けられたオブジェクトインスタンスが破棄されるたびにその情報を破棄します。

#### 弱いマップの使用と制限

ウィークマップを使用するか通常マップを使用するかを決定する際には、オブジェクトキーのみを使用するかどうかを考慮する必要があります。いつでもあなたはオブジェクトキーだけを使用するつもりです、そして、最良の選択は弱い地図です。これにより、メモリ使用量を最適化し、メモリリークを回避できるようになります。これは、余分なデータがアクセスできなくなった後でも保持されないようにするためです。

弱いマップは内容の可視性がほとんどないので、`forEach()`メソッド、`size`プロパティ、`clear()`メソッドを使って項目を管理することはできません。何らかの検査機能が必要な場合は、通常のマップが適しています。メモリ使用量に注目してください。

もちろん、非オブジェクトキーだけを使用したい場合は、通常のマップが唯一の選択肢です。

## まとめ

ECMAScript6ではJavaScriptにセットとマップが正式に導入されています。これに先立って、開発者はしばしばオブジェクトを使用してセットとマップの両方を模倣し、多くの場合オブジェクトのプロパティに関連する制限のために問題に陥っていました。

セットは一意の値の順序付きリストです。等価性を判断するために値が強制されません。 setは重複した値を自動的に削除するので、配列を使って重複をフィルタリングして結果を返すことができます。セットは配列のサブクラスではないため、セットの値にランダムにアクセスすることはできません。その代わりに、`has()`メソッドを使って値がセットに含まれているかどうかを判断し、`size`プロパティを使ってセットの値の数を調べることができます。`Set`型には、各設定値を処理するための`forEach()`メソッドもあります。

弱い集合は、オブジェクトのみを含むことができる特殊集合です。オブジェクトには弱い参照が格納されます。つまり、弱いセットのアイテムは、そのアイテムがオブジェクトへの残りの唯一の参照である場合、ガベージコレクションをブロックしません。弱い設定内容はメモリ管理の複雑さのため検査できませんので、一緒にグループ化する必要があるオブジェクトを追跡するためにのみ弱いセットを使用することをお勧めします。

マップは、キーが任意のデータ型であるキーと値のペアの順序です。セットと同様に、キーは強制的に等価性を判定するために強制されません。つまり、数値キー`5`と文字列`5`を2つの別個のキーとして持つことができます。任意のデータ型の値は、`set()`メソッドを使用してキーに関連付けることができ、その値は後で`get()`メソッドを使って取り出すことができます。マップには、アイテムアクセスを容易にするための`size`プロパティと`forEach()`メソッドもあります。

弱マップは、オブジェクトキーのみを持つ特殊なマップです。ウィークセットと同様に、オブジェクトキー参照は弱く、オブジェクトへの参照が残っているときにはガベージコレクションを防止しません。キーがガベージコレクションされると、そのキーに関連付けられた値もウィークマップから削除されます。このメモリ管理の面では、ウィークマップは、ライフサイクルがそれらにアクセスするコードの外部で管理されているオブジェクトと追加の情​​報を関連付けるのに一意に適しています。
